# 多线程

## 1、线程

- process进程、thread线程(调度单位)

### 线程创建三种方式

- Thread类

- Runnable接口
  - 避免单继承的局限性，方便一个对象被多个线程使用


- Callable接口
  - 有返回值

### 线程状态和方法

- 状态
  - New初始状态：线程被创建，还没调用start()
  - Runnable运行状态：对象start()后，包括ready就绪状态和running运行状态
  - Blocked阻塞状态：调用同步方法，但是没有获得到锁
  - Waiting等待状态：等待其他线程执行
  - Time_waiting超时等待状态：不同于waiting，时间到了自动返回
  - terminated终止状态：线程执行完成

- 方法
  - 线程休眠：sleep(long millis) 让正在执行的线程休息mills毫秒(1000毫秒=1秒）
  - 线程礼让：yield() 暂停当前正在执行的线程对象，由cpu重新调度
  - 线程强制执行：join() 停止当前线程，由该线程终止后执行
  - setPriority(int newPriority) 更改线程优先级，先设置后启动
  - interrupt() 中断线程，一般中断线程使用暂停标志位实现
  - isAlive() 测试线程是否处于活动状态

- 优先级和守护线程
  - min = 1，max = 10，线程默认优先级为5
  - 守护线程，如GC线程、监控日志线程。虚拟机不管守护线程是否执行完毕，setDaemon(true)

### 线程同步

- 并发：同一个对象被**多线程**同时操作
- 线程同步：等待机制，需要同时访问的线程进入对象的等待池形成队列（队列+锁）
- 同步问题：
  - 加锁和释放锁导致频繁上下文切换和调度延时
  - 优先级高的线程等待优先级低的线程，性能问题；线程执行时间短，排队两小时，执行五分钟
- synchronized同步关键字：
  - 同步方法：无需指定同步监视器，默认为this即对象本身
  - 同步块：synchronized (obj){} 将共享的资源放进obj，同步监视器
- 死锁：
  - 某个代码块同时拥有**两个及以上对象**的锁，就可能出现死锁
  - 产生的四个必要条件：
    - 互斥条件(只能一个线程拿到)
    - 请求与保持条件(请求其他资源，同时保持有的资源)
    - 不剥夺条件
    - 循环等待条件(若干个线程形成循环等待资源的关系)

- Lock锁
  - 显式锁，需要手动开启和手动关闭，一般放在try、catch中，性能比synchronized更优

## 2、线程协作

### 生产者消费者问题

- 生产、消费线程不仅共享资源，而且相互依赖
- synchronized通过阻止操作实现线程的同步，但不能进行消息的传递，所以无法解决这个问题
- 解决方法(PV操作)：
  - 管程法：生产者将生产好的数据放入缓冲区，消费者从缓冲区取数据
  - 信号灯法：用一个布尔值做判断

## 3、线程池

- 池化思想：线程池、字符串常量池、数据库连接池
- 优点：
  - 提高线程利用率（单一线程，需要不断创建对象使用后销毁）
  - 提高程序的响应速度
  - 便于管理程序的全部线程
  - 可以控制并发数

### 线程池的使用

- ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor

  - ```java
    execute(Runnable command) //执行线程，没有返回值
    ```

  - ```java
    submit(Callable<T> task) //提交线程并执行，有返回值
    ```

- Executors：工具类、线程池的工厂类，用于创建不同类型的线程池

## 4、扩展

### Lambda

- 为什么用？避免匿名内部类定义过多，代码更加简洁

- Runnble就是函数式接口，使用lambda可以快速创建线程

```java
  //定义一个函数式接口(一个方法)
  interface ILike{
      void lambda();
  }
  ILike like5 = ()->{
     System.out.println("I like Lambda5");
  };
  like5.lambda();
```

### 静态代理

- 真实角色、代理对象实现同一个接口，代理对象里包含真实角色，真实角色负责核心业务，代理对象处理其他
- 代理对象=Thread、真实角色=线程内容，接口= Runnable

